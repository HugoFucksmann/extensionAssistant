import * as vscode from 'vscode';
import { SQLiteStorage } from '../../db/SQLiteStorage';
import { EventBus } from '../../utils/eventBus';
import { Events } from '../../utils/events';
import { 
  TemporaryMemory, 
  ChatMemory, 
  ProjectMemory,
  ChatMessage,
  Chat,
  ChatSummary
} from './tools';

/**
 * MemoryAgent es responsable de gestionar toda la memoria de la extensión.
 * Maneja tanto la memoria persistente (proyecto y chat) como la memoria temporal
 * que solo dura durante un intercambio de mensajes.
 */
export class MemoryAgent {
  // Herramientas de memoria
  private temporaryMemory: TemporaryMemory;
  private chatMemory: ChatMemory;
  private projectMemory: ProjectMemory;
  
  // Estado actual
  private currentChatId: string | null = null;
  private messages: ChatMessage[] = [];
  private chatList: ChatSummary[] = [];
  
  // Disposables para limpiar suscripciones
  private disposables: { dispose: () => void }[] = [];

  constructor(context: vscode.ExtensionContext) {
    const storage = new SQLiteStorage(context);
    
    // Inicializar herramientas de memoria
    this.temporaryMemory = new TemporaryMemory();
    this.chatMemory = new ChatMemory(storage);
    this.projectMemory = new ProjectMemory(storage);
    
    // Configurar listeners de eventos
    this.setupEventListeners();
  }

  /**
   * Configura los listeners de eventos para responder a acciones del sistema
   */
  private setupEventListeners(): void {
    // Escuchar cuando se solicita un nuevo chat
    const newChatUnsubscribe = EventBus.subscribe(
      Events.UI.NEW_CHAT_REQUESTED,
      async () => {
        await this.createNewChat();
      }
    );
    
    // Escuchar cuando se solicita cargar un chat
    const loadChatUnsubscribe = EventBus.subscribe(
      Events.UI.LOAD_CHAT_REQUESTED,
      async (data: { chatId: string }) => {
        await this.loadChat(data.chatId);
      }
    );
    
    // Guardar las funciones para cancelar suscripciones
    this.disposables.push(
      { dispose: newChatUnsubscribe },
      { dispose: loadChatUnsubscribe }
    );
  }

  /**
   * Almacena una memoria para un proyecto específico
   * @param projectPath La ruta del proyecto como identificador
   * @param key La clave bajo la cual almacenar la memoria
   * @param content El contenido a almacenar
   */
  public async storeProjectMemory(projectPath: string, key: string, content: string): Promise<void> {
    return this.projectMemory.storeProjectMemory(projectPath, key, content);
  }

  /**
   * Recupera una memoria para un proyecto específico
   * @param projectPath La ruta del proyecto como identificador
   * @param key La clave para recuperar la memoria
   */
  public async getProjectMemory(projectPath: string, key: string): Promise<any> {
    return this.projectMemory.getProjectMemory(projectPath, key);
  }

  /**
   * Almacena una memoria temporal para el intercambio de mensajes actual
   * @param key La clave bajo la cual almacenar la memoria
   * @param content El contenido a almacenar
   */
  public storeTemporaryMemory(key: string, content: any): void {
    this.temporaryMemory.store(key, content);
  }

  /**
   * Recupera una memoria temporal
   * @param key La clave para recuperar la memoria
   */
  public getTemporaryMemory(key: string): any {
    return this.temporaryMemory.get(key);
  }

  /**
   * Limpia todas las memorias temporales
   * Debe llamarse después de completar cada intercambio de mensajes
   */
  public clearTemporaryMemory(): void {
    this.temporaryMemory.clear();
  }

  /**
   * Crea un nuevo chat y retorna su ID
   * Si hay un chat actual con mensajes, lo guarda automáticamente
   * @returns El ID del nuevo chat
   */
  public async createNewChat(): Promise<string> {
    // Guardar el chat actual si tiene mensajes
    await this.saveCurrentChatIfNeeded();
    
    // Generar un ID único para el nuevo chat
    const chatId = this.chatMemory.generateChatId();
    this.currentChatId = chatId;
    this.messages = [];
    
    // Publicar evento de nuevo chat creado
    EventBus.publish(Events.MEMORY.NEW_CHAT_CREATED, { chatId });
    
    console.log('Nuevo chat creado:', chatId);
    return chatId;
  }

  /**
   * Añade un mensaje al chat actual
   * @param message El mensaje a añadir
   */
  public async addMessage(message: Partial<ChatMessage>): Promise<void> {
    // Asegurar que tenemos un chat actual
    if (!this.currentChatId) {
      await this.createNewChat();
    }
    
    // Completar los campos faltantes del mensaje
    const completeMessage: ChatMessage = {
      role: message.role || 'user',
      text: message.text || '',
      timestamp: message.timestamp || new Date().toISOString()
    };
    
    // Añadir el mensaje a la lista
    this.messages.push(completeMessage);
  }
  
  /**
   * Procesa un par de mensajes (usuario y asistente) y los añade al chat actual
   * @param userText El texto del mensaje del usuario
   * @param assistantText El texto de la respuesta del asistente
   * @returns Un objeto con el mensaje del usuario y la respuesta del asistente
   */
  public async processMessagePair(
    userText: string, 
    assistantText: string
  ): Promise<{userMessage: ChatMessage, assistantMessage: ChatMessage}> {
    // Añadir mensaje del usuario
    const userMessage: ChatMessage = {
      role: 'user',
      text: userText,
      timestamp: new Date().toISOString()
    };
    
    await this.addMessage(userMessage);
    
    // Añadir mensaje del asistente
    const assistantMessage: ChatMessage = {
      role: 'assistant',
      text: assistantText,
      timestamp: new Date().toISOString()
    };
    
    await this.addMessage(assistantMessage);
    
    return { userMessage, assistantMessage };
  }
  
  /**
   * Obtiene todos los mensajes del chat actual
   * @returns Array con los mensajes del chat actual
   */
  public getMessages(): ChatMessage[] {
    return [...this.messages];
  }

  /**
   * Guarda el chat actual con sus mensajes si es necesario
   * @returns Promise que se resuelve cuando se guarda el chat
   */
  public async saveCurrentChatIfNeeded(): Promise<void> {
    // Verificar que tenemos un ID de chat y al menos un mensaje
    if (!this.currentChatId) {
      console.log('No hay chat actual para guardar');
      return;
    }
    
    // Solo guardar si hay mensajes
    if (this.messages.length === 0) {
      console.log('No hay mensajes para guardar en el chat:', this.currentChatId);
      return;
    }
    
    console.log('Guardando chat actual:', this.currentChatId, 'con', this.messages.length, 'mensajes');
    
    // Generar un título a partir del primer mensaje del usuario
    const firstUserMessage = this.messages.find(m => m.role === 'user');
    const title = firstUserMessage 
      ? firstUserMessage.text.substring(0, 30) + (firstUserMessage.text.length > 30 ? '...' : '')
      : `Chat ${new Date().toLocaleString()}`;
    
    // Crear un objeto de chat con metadatos
    const chat: Chat = {
      id: this.currentChatId,
      title,
      timestamp: new Date().toISOString(),
      messages: this.messages,
      preview: firstUserMessage ? firstUserMessage.text.substring(0, 50) : ''
    };
    
    try {
      // Almacenar el chat en la base de datos
      await this.chatMemory.saveChat(this.currentChatId, chat);
      
      // Actualizar la lista de chats
      const updatedList = await this.chatMemory.updateChatList(chat);
      
      // Actualizar la lista local
      this.chatList = updatedList;
      
      // Publicar evento de lista de chats actualizada
      EventBus.publish(Events.MEMORY.CHAT_LIST_UPDATED, updatedList);
      
      console.log('Chat guardado correctamente:', this.currentChatId);
    } catch (error) {
      console.error('Error al guardar el chat:', error);
      throw error; // Propagar el error para manejarlo en niveles superiores
    }
  }

  /**
   * Carga la lista de todos los chats
   * @returns Promise que se resuelve con la lista de chats
   */
  public async loadChatList(): Promise<ChatSummary[]> {
    try {
      this.chatList = await this.chatMemory.getChatList();
      
      // Publicar evento de lista de chats actualizada
      EventBus.publish(Events.MEMORY.CHAT_LIST_UPDATED, this.chatList);
      
      return this.chatList;
    } catch (error) {
      console.error('Error al obtener la lista de chats:', error);
      return [];
    }
  }

  /**
   * Carga un chat por su ID
   * @param chatId El ID del chat a cargar
   * @returns Promise que se resuelve con los datos del chat
   */
  public async loadChat(chatId: string): Promise<Chat | null> {
    try {
      // Guardar el chat actual antes de cargar uno nuevo
      await this.saveCurrentChatIfNeeded();
      
      const chat = await this.chatMemory.loadChat(chatId);
      if (chat) {
        this.currentChatId = chatId;
        this.messages = chat.messages || [];
        
        // Publicar evento de chat cargado
        EventBus.publish(Events.MEMORY.CHAT_LOADED, chat);
        
        return chat;
      }
      return null;
    } catch (error) {
      console.error('Error al cargar el chat:', error);
      return null;
    }
  }

  /**
   * Inicializa el agente de memoria
   * Carga la lista de chats al inicio y asegura que haya un chat actual
   */
  public async initialize(): Promise<void> {
    console.log('MemoryAgent inicializado');
    await this.loadChatList();
    
    // Asegurar que siempre haya un chat actual válido
    if (!this.currentChatId) {
      // Generar un ID único para el nuevo chat
      this.currentChatId = this.chatMemory.generateChatId();
      this.messages = [];
      console.log('Nuevo chat creado al inicializar:', this.currentChatId);
    }
  }

  /**
   * Limpia los recursos cuando se desactiva la extensión
   */
  public dispose(): void {
    console.log('MemoryAgent eliminado');
    
    // Guardar cualquier estado pendiente
    this.saveCurrentChatIfNeeded().catch(err => {
      console.error('Error al guardar el chat durante la desactivación:', err);
    });
    
    // Cancelar todas las suscripciones a eventos
    this.disposables.forEach(disposable => disposable.dispose());
    this.disposables = [];
  }
}
