import { ReActNodeType } from '../core/config';
import { createInitialReActState, ReActState, ReActNodeFunction } from './types';
import { PromptManager } from '../prompts/promptManager';
import { ModelManager } from '../models/modelManager';
import { ToolRegistry } from '../tools/toolRegistry';
import { RunnableLambda } from '@langchain/core/runnables';
import { EventType, NodeEventPayload, ToolExecutionPayload } from '../core/events';
import { eventBus } from '../core/eventBus';

/**
 * Clase que implementa los nodos del grafo ReAct
 */
export class ReActNodes {
  private promptManager: PromptManager;
  private modelManager: ModelManager;
  private toolRegistry: ToolRegistry;

  constructor(
    promptManager: PromptManager,
    modelManager: ModelManager,
    toolRegistry: ToolRegistry
  ) {
    this.promptManager = promptManager;
    this.modelManager = modelManager;
    this.toolRegistry = toolRegistry;
  }

  /**
   * Nodo para el análisis inicial del mensaje del usuario
   */
  initialAnalysisNode(): RunnableLambda<ReActState, ReActState> {
    return new RunnableLambda({
      func: async (state: ReActState): Promise<ReActState> => {
        const startTime = Date.now();
        
        try {
          // Emitir evento de inicio del nodo
          eventBus.emitEvent<NodeEventPayload>(EventType.NODE_START, {
            type: ReActNodeType.INITIAL_ANALYSIS,
            state
          }, 'ReActNodes.initialAnalysisNode');
          
          // Obtener el prompt para el análisis inicial
          const prompt = this.promptManager.getPrompt(ReActNodeType.INITIAL_ANALYSIS);
          
          // Preparar las variables para el prompt
          const variables = {
            userMessage: state.userMessage,
            context: state.context || state.metadata.contextData || {},
            availableTools: this.toolRegistry.getToolNames().join(', ')
          };
          
          // Generar el análisis inicial
          const response = await this.modelManager.generateText(
            prompt.formatPrompt(variables),
            state.metadata.modelName
          );
          
          // Procesar la respuesta
          const analysis = JSON.parse(response);
          
          // Actualizar el estado con el análisis
          const updatedState: ReActState = {
            ...state,
            initialAnalysis: {
              intent: analysis.intent,
              objectives: analysis.objectives,
              requiredTools: analysis.requiredTools || [],
              relevantContext: analysis.relevantContext || ''
            },
            currentNode: ReActNodeType.REASONING
          };
          
          const duration = Date.now() - startTime;
          
          // Emitir evento de finalización del nodo
          eventBus.emitEvent<NodeEventPayload>(EventType.NODE_COMPLETE, {
            type: ReActNodeType.INITIAL_ANALYSIS,
            state: updatedState,
            duration
          }, 'ReActNodes.initialAnalysisNode');
          
          return updatedState;
        } catch (error) {
          const duration = Date.now() - startTime;
          
          // Emitir evento de error del nodo
          eventBus.emitEvent<NodeEventPayload>(EventType.NODE_ERROR, {
            type: ReActNodeType.INITIAL_ANALYSIS,
            state,
            error: error as Error,
            duration
          }, 'ReActNodes.initialAnalysisNode');
          
          throw error;
        }
      }
    });
  }

  /**
   * Nodo para el razonamiento y planificación
   */
  reasoningNode(): RunnableLambda<ReActState, ReActState> {
    return new RunnableLambda({
      func: async (state: ReActState): Promise<ReActState> => {
        const startTime = Date.now();
        
        try {
          // Emitir evento de inicio del nodo
          eventBus.emitEvent<NodeEventPayload>(EventType.NODE_START, {
            type: ReActNodeType.REASONING,
            state
          }, 'ReActNodes.reasoningNode');
          
          // Obtener el prompt para el razonamiento
          const prompt = this.promptManager.getPrompt(ReActNodeType.REASONING);
          
          // Preparar las variables para el prompt
          const variables = {
            userMessage: state.userMessage,
            initialAnalysis: state.initialAnalysis,
            context: state.context || state.metadata.contextData || {},
            availableTools: this.toolRegistry.getToolNames().join(', ')
          };
          
          // Generar el razonamiento
          const response = await this.modelManager.generateText(
            prompt.formatPrompt(variables),
            state.metadata.modelName
          );
          
          // Procesar la respuesta
          const reasoning = JSON.parse(response);
          
          // Actualizar el estado con el razonamiento
          const updatedState: ReActState = {
            ...state,
            reasoning: {
              plan: reasoning.plan,
              steps: reasoning.steps,
              currentStep: 0,
              toolsToUse: reasoning.toolsToUse || []
            },
            currentNode: ReActNodeType.ACTION
          };
          
          // Actualizar el historial
          if (!updatedState.history.reasoning) {
            updatedState.history.reasoning = [];
          }
          updatedState.history.reasoning.push(reasoning.plan);
          
          const duration = Date.now() - startTime;
          
          // Emitir evento de finalización del nodo
          eventBus.emitEvent<NodeEventPayload>(EventType.NODE_COMPLETE, {
            type: ReActNodeType.REASONING,
            state: updatedState,
            duration
          }, 'ReActNodes.reasoningNode');
          
          return updatedState;
        } catch (error) {
          const duration = Date.now() - startTime;
          
          // Emitir evento de error del nodo
          eventBus.emitEvent<NodeEventPayload>(EventType.NODE_ERROR, {
            type: ReActNodeType.REASONING,
            state,
            error: error as Error,
            duration
          }, 'ReActNodes.reasoningNode');
          
          throw error;
        }
      }
    });
  }

  /**
   * Nodo para la ejecución de acciones
   */
  actionNode(): RunnableLambda<ReActState, ReActState> {
    return new RunnableLambda({
      func: async (state: ReActState): Promise<ReActState> => {
        const startTime = Date.now();
        
        try {
          // Emitir evento de inicio del nodo
          eventBus.emitEvent<NodeEventPayload>(EventType.NODE_START, {
            type: ReActNodeType.ACTION,
            state
          }, 'ReActNodes.actionNode');
          
          // Verificar si hay un plan de razonamiento
          if (!state.reasoning || !state.reasoning.steps || state.reasoning.steps.length === 0) {
            throw new Error('No hay un plan de razonamiento definido para ejecutar acciones');
          }
          
          // Obtener el paso actual
          const currentStepIndex = state.reasoning.currentStep;
          if (currentStepIndex >= state.reasoning.steps.length) {
            throw new Error('Índice de paso actual fuera de rango');
          }
          
          const currentStep = state.reasoning.steps[currentStepIndex];
          
          // Verificar si el paso tiene una herramienta asociada
          if (!currentStep.toolName) {
            throw new Error('El paso actual no tiene una herramienta asociada');
          }
          
          // Verificar si la herramienta existe
          if (!this.toolRegistry.hasTool(currentStep.toolName)) {
            throw new Error(`La herramienta ${currentStep.toolName} no está registrada`);
          }
          
          // Preparar la acción
          const action = {
            toolName: currentStep.toolName,
            toolInput: currentStep.parameters || {},
            isComplete: false
          };
          
          // Emitir evento de inicio de ejecución de herramienta
          eventBus.emitEvent<ToolExecutionPayload>(EventType.TOOL_EXECUTION_START, {
            toolName: action.toolName,
            params: action.toolInput
          }, 'ReActNodes.actionNode');
          
          // Ejecutar la herramienta
          const toolStartTime = Date.now();
          const toolResult = await this.toolRegistry.executeTool(
            action.toolName,
            action.toolInput
          );
          const toolDuration = Date.now() - toolStartTime;
          
          // Actualizar la acción con el resultado
          action.toolOutput = toolResult;
          action.isComplete = true;
          
          // Emitir evento de finalización de ejecución de herramienta
          eventBus.emitEvent<ToolExecutionPayload>(EventType.TOOL_EXECUTION_COMPLETE, {
            toolName: action.toolName,
            params: action.toolInput,
            result: toolResult,
            duration: toolDuration
          }, 'ReActNodes.actionNode');
          
          // Actualizar el estado con la acción
          const updatedState: ReActState = {
            ...state,
            action,
            currentNode: ReActNodeType.REFLECTION
          };
          
          // Actualizar el historial
          if (!updatedState.history.actions) {
            updatedState.history.actions = [];
          }
          updatedState.history.actions.push({
            toolName: action.toolName,
            input: action.toolInput,
            output: action.toolOutput,
            timestamp: Date.now()
          });
          
          // Actualizar los pasos intermedios
          updatedState.intermediateSteps.push({
            action: {
              tool: action.toolName,
              toolInput: action.toolInput
            },
            observation: action.toolOutput,
            timestamp: Date.now()
          });
          
          const duration = Date.now() - startTime;
          
          // Emitir evento de finalización del nodo
          eventBus.emitEvent<NodeEventPayload>(EventType.NODE_COMPLETE, {
            type: ReActNodeType.ACTION,
            state: updatedState,
            duration
          }, 'ReActNodes.actionNode');
          
          return updatedState;
        } catch (error) {
          const duration = Date.now() - startTime;
          
          // Emitir evento de error del nodo
          eventBus.emitEvent<NodeEventPayload>(EventType.NODE_ERROR, {
            type: ReActNodeType.ACTION,
            state,
            error: error as Error,
            duration
          }, 'ReActNodes.actionNode');
          
          // Actualizar el estado con el error
          const updatedState: ReActState = {
            ...state,
            action: {
              ...(state.action || { toolName: '', toolInput: {}, isComplete: false }),
              error: (error as Error).message
            },
            currentNode: ReActNodeType.REFLECTION
          };
          
          return updatedState;
        }
      }
    });
  }

  /**
   * Nodo para la reflexión sobre los resultados
   */
  reflectionNode(): RunnableLambda<ReActState, ReActState> {
    return new RunnableLambda({
      func: async (state: ReActState): Promise<ReActState> => {
        const startTime = Date.now();
        
        try {
          // Emitir evento de inicio del nodo
          eventBus.emitEvent<NodeEventPayload>(EventType.NODE_START, {
            type: ReActNodeType.REFLECTION,
            state
          }, 'ReActNodes.reflectionNode');
          
          // Obtener el prompt para la reflexión
          const prompt = this.promptManager.getPrompt(ReActNodeType.REFLECTION);
          
          // Preparar las variables para el prompt
          const variables = {
            userMessage: state.userMessage,
            initialAnalysis: state.initialAnalysis,
            reasoning: state.reasoning,
            action: state.action,
            intermediateSteps: state.intermediateSteps,
            context: state.context || state.metadata.contextData || {}
          };
          
          // Generar la reflexión
          const response = await this.modelManager.generateText(
            prompt.formatPrompt(variables),
            state.metadata.modelName
          );
          
          // Procesar la respuesta
          const reflection = JSON.parse(response);
          
          // Actualizar el estado con la reflexión
          const updatedState: ReActState = {
            ...state,
            reflection: {
              success: reflection.success,
              insights: reflection.insights || [],
              nextSteps: reflection.nextSteps || [],
              needsCorrection: reflection.needsCorrection || false
            }
          };
          
          // Actualizar el historial
          if (!updatedState.history.reflections) {
            updatedState.history.reflections = [];
          }
          updatedState.history.reflections.push(reflection.insights.join('\n'));
          
          // Determinar el siguiente nodo
          if (reflection.needsCorrection) {
            updatedState.currentNode = ReActNodeType.CORRECTION;
          } else if (state.reasoning && 
                    state.reasoning.currentStep < state.reasoning.steps.length - 1) {
            // Si hay más pasos en el plan, incrementar el paso actual y volver a ACTION
            updatedState.reasoning = {
              ...state.reasoning,
              currentStep: state.reasoning.currentStep + 1
            };
            updatedState.currentNode = ReActNodeType.ACTION;
          } else {
            // Si no hay más pasos, generar la respuesta final
            updatedState.currentNode = ReActNodeType.RESPONSE;
          }
          
          const duration = Date.now() - startTime;
          
          // Emitir evento de finalización del nodo
          eventBus.emitEvent<NodeEventPayload>(EventType.NODE_COMPLETE, {
            type: ReActNodeType.REFLECTION,
            state: updatedState,
            duration
          }, 'ReActNodes.reflectionNode');
          
          return updatedState;
        } catch (error) {
          const duration = Date.now() - startTime;
          
          // Emitir evento de error del nodo
          eventBus.emitEvent<NodeEventPayload>(EventType.NODE_ERROR, {
            type: ReActNodeType.REFLECTION,
            state,
            error: error as Error,
            duration
          }, 'ReActNodes.reflectionNode');
          
          throw error;
        }
      }
    });
  }

  /**
   * Nodo para la corrección del plan
   */
  correctionNode(): RunnableLambda<ReActState, ReActState> {
    return new RunnableLambda({
      func: async (state: ReActState): Promise<ReActState> => {
        const startTime = Date.now();
        
        try {
          // Emitir evento de inicio del nodo
          eventBus.emitEvent<NodeEventPayload>(EventType.NODE_START, {
            type: ReActNodeType.CORRECTION,
            state
          }, 'ReActNodes.correctionNode');
          
          // Obtener el prompt para la corrección
          const prompt = this.promptManager.getPrompt(ReActNodeType.CORRECTION);
          
          // Preparar las variables para el prompt
          const variables = {
            userMessage: state.userMessage,
            initialAnalysis: state.initialAnalysis,
            reasoning: state.reasoning,
            action: state.action,
            reflection: state.reflection,
            intermediateSteps: state.intermediateSteps,
            context: state.context || state.metadata.contextData || {},
            availableTools: this.toolRegistry.getToolNames().join(', ')
          };
          
          // Generar la corrección
          const response = await this.modelManager.generateText(
            prompt.formatPrompt(variables),
            state.metadata.modelName
          );
          
          // Procesar la respuesta
          const correction = JSON.parse(response);
          
          // Guardar el plan original para referencia
          const originalPlan = state.reasoning ? state.reasoning.plan : '';
          
          // Actualizar el estado con la corrección
          const updatedState: ReActState = {
            ...state,
            correction: {
              originalPlan,
              revisedPlan: correction.revisedPlan,
              reason: correction.reason
            },
            reasoning: {
              plan: correction.revisedPlan,
              steps: correction.steps,
              currentStep: 0,
              toolsToUse: correction.toolsToUse || []
            },
            currentNode: ReActNodeType.ACTION
          };
          
          // Actualizar el historial
          if (!updatedState.history.corrections) {
            updatedState.history.corrections = [];
          }
          updatedState.history.corrections.push(correction.reason);
          
          const duration = Date.now() - startTime;
          
          // Emitir evento de finalización del nodo
          eventBus.emitEvent<NodeEventPayload>(EventType.NODE_COMPLETE, {
            type: ReActNodeType.CORRECTION,
            state: updatedState,
            duration
          }, 'ReActNodes.correctionNode');
          
          return updatedState;
        } catch (error) {
          const duration = Date.now() - startTime;
          
          // Emitir evento de error del nodo
          eventBus.emitEvent<NodeEventPayload>(EventType.NODE_ERROR, {
            type: ReActNodeType.CORRECTION,
            state,
            error: error as Error,
            duration
          }, 'ReActNodes.correctionNode');
          
          throw error;
        }
      }
    });
  }

  /**
   * Nodo para la generación de la respuesta final
   */
  responseNode(): RunnableLambda<ReActState, ReActState> {
    return new RunnableLambda({
      func: async (state: ReActState): Promise<ReActState> => {
        const startTime = Date.now();
        
        try {
          // Emitir evento de inicio del nodo
          eventBus.emitEvent<NodeEventPayload>(EventType.NODE_START, {
            type: ReActNodeType.RESPONSE,
            state
          }, 'ReActNodes.responseNode');
          
          // Obtener el prompt para la respuesta
          const prompt = this.promptManager.getPrompt(ReActNodeType.RESPONSE);
          
          // Preparar las variables para el prompt
          const variables = {
            userMessage: state.userMessage,
            initialAnalysis: state.initialAnalysis,
            reasoning: state.reasoning,
            intermediateSteps: state.intermediateSteps,
            context: state.context || state.metadata.contextData || {}
          };
          
          // Generar la respuesta
          const response = await this.modelManager.generateText(
            prompt.formatPrompt(variables),
            state.metadata.modelName
          );
          
          // Actualizar el estado con la respuesta
          const updatedState: ReActState = {
            ...state,
            finalResponse: response,
            currentNode: ReActNodeType.END,
            metadata: {
              ...state.metadata,
              endTime: Date.now()
            }
          };
          
          const duration = Date.now() - startTime;
          
          // Emitir evento de finalización del nodo
          eventBus.emitEvent<NodeEventPayload>(EventType.NODE_COMPLETE, {
            type: ReActNodeType.RESPONSE,
            state: updatedState,
            duration
          }, 'ReActNodes.responseNode');
          
          return updatedState;
        } catch (error) {
          const duration = Date.now() - startTime;
          
          // Emitir evento de error del nodo
          eventBus.emitEvent<NodeEventPayload>(EventType.NODE_ERROR, {
            type: ReActNodeType.RESPONSE,
            state,
            error: error as Error,
            duration
          }, 'ReActNodes.responseNode');
          
          throw error;
        }
      }
    });
  }
}
