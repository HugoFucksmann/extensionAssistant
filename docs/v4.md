while (['planning', 'executing', 'evaluating'].includes(context.getValue('processingStatus'))) {
    const currentStatus = context.getValue('processingStatus');

    try {
        if (currentStatus === 'planning') {
            console.log(`[Orchestrator:${chatId}] Status: Planning next step...`);
            // Planner determines the next step and updates context.currentPlan/status
            const nextStep = this.plannerService.planNextStep(context);

            if (nextStep) {
                // Add step to execution queue (or update index if using an array plan)
                // For simplicity, let's assume planNextStep puts the next step at index 0 and we shift it off.
                context.setValue('currentPlan', [nextStep, ...(context.getValue('currentPlan') || [])]);
                context.setValue('currentStepIndex', 0); // Reset index or manage queue
                context.setValue('processingStatus', 'executing');
                // Optional: Add a "System" message to history indicating the next action
                context.addMessage('system', `Planning: Next step is '${nextStep.name}'.`);
            } else {
                // Planner determined the process is complete or needs user input
                // Planner should have set context.processingStatus to 'complete' or 'needs_user_input'
                 console.log(`[Orchestrator:${chatId}] Planner indicates process status: ${context.getValue('processingStatus')}`);
                 // Exit loop if status is no longer iterative
                 if (!['planning', 'executing', 'evaluating'].includes(context.getValue('processingStatus'))) break;
            }

        } else if (currentStatus === 'executing') {
            console.log(`[Orchestrator:${chatId}] Status: Executing step...`);
            const plan = context.getValue<ExecutionStep[]>('currentPlan') || [];
            const stepToExecute = plan[context.getValue<number>('currentStepIndex') || 0]; // Get step from plan

            if (!stepToExecute) {
                 console.warn(`[Orchestrator:${chatId}] Execution status but no step in plan at index ${context.getValue('currentStepIndex')}. Setting status to error.`);
                 context.setValue('processingStatus', 'error');
                 context.setValue('finalResponseContent', "Internal error: No step found to execute.");
                 break;
            }

            const stepResult = await this.stepExecutor.runStep(stepToExecute, context);
            context.setValue('lastStepResult', stepResult); // Store for planner evaluation
            context.setValue('processingStatus', 'evaluating'); // Move to evaluation phase
            // Optional: Add a "System" message about step success/failure
             context.addMessage('system', `Step '${stepToExecute.name}' completed. Success: ${stepResult.success}.`);


        } else if (currentStatus === 'evaluating') {
             console.log(`[Orchestrator:${chatId}] Status: Evaluating step result...`);
             const lastResult = context.getValue<StepResult>('lastStepResult');
             if (!lastResult) {
                 console.warn(`[Orchestrator:${chatId}] Evaluation status but no lastStepResult. Setting status to error.`);
                 context.setValue('processingStatus', 'error');
                 context.setValue('finalResponseContent', "Internal error: No step result to evaluate.");
                  break;
             }
             // Planner evaluates the result and updates the context/plan/status
             this.plannerService.evaluateStepResult(context, lastResult);
             // Move the step index or remove from queue
             const currentStepIndex = context.getValue<number>('currentStepIndex') || 0;
             context.setValue('currentStepIndex', currentStepIndex + 1); // Move to next logical step slot
             context.setValue('processingStatus', 'planning'); // Go back to planning the next action based on evaluation
             context.addMessage('system', `Evaluation complete for '${lastResult.step.name}'. Planning next action.`);
        }

         // IMPORTANT: Save context state here after each phase (planning, executing, evaluating)
         // In a real async implementation, this save would trigger the next execution iteration.
         // For this synchronous loop example, it just ensures persistence points.
         // await this.saveContextState(chatId, context.getState()); // Need a method for this in Orchestrator or ChatService

    } catch (error: any) {
        console.error(`[Orchestrator:${chatId}] Error during process loop:`, error);
        context.setValue('processingStatus', 'error');
        context.setValue('finalResponseContent', `An unexpected error occurred during processing: ${error.message}`);
        break; // Exit loop on unexpected error
    }
}

// Loop finished. Status is now 'complete', 'error', or 'needs_user_input'.
console.log(`[Orchestrator:${chatId}] Process loop finished with status: ${context.getValue('processingStatus')}`);

// Generate and add the final message
let finalMessage = context.getValue<string>('finalResponseContent');
if (!finalMessage) {
     const status = context.getValue('processingStatus');
     if (status === 'complete') {
         finalMessage = "Process completed successfully."; // Fallback
     } else if (status === 'needs_user_input') {
         finalMessage = context.getValue('requiresUserInputReason') || "The process requires your input to continue.";
     } else if (status === 'error') {
         finalMessage = `An error occurred: ${context.getValue('finalResponseContent') || 'See logs for details.'}`; // Fallback
     } else {
         finalMessage = `Process ended with unexpected status: ${status}`;
     }
}
 context.addMessage('assistant', finalMessage);

 // Final save of the context state
 // await this.saveContextState(chatId, context.getState()); // Need a method for this

return finalMessage; // Return the final message content