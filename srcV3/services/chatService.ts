// src/services/ChatService.ts
import * as vscode from 'vscode';



import { ModelManager } from '../models/config/ModelManager';
import { Orchestrator } from '../orchestrator/orchestrator';
import { GlobalContext, SessionContext, ConversationContext, FlowContext } from '../orchestrator/context';
import { AgentOrchestratorService } from '../orchestrator/agents/AgentOrchestratorService';

import { Chat, ChatMessage, ChatRepository, IChatRepository, MemoryItem } from '../store';


// Define the maximum number of planning attempts for a single user turn, including replanning.
const MAX_PLANNING_ATTEMPTS = 3;

/**
 * Service for managing conversation interactions and integrating the AI model.
 * This service orchestrates the steps of a chat turn, including replanning.
 * It interacts with the database, the orchestration layer, and the background agents.
 */
export class ChatService {
  private repository: IChatRepository;
  private activeConversations: Map<string, ConversationContext> = new Map();
  private currentChatId: string | null = null;
  private pendingNewChat: boolean = false; // Flag to indicate if the next message should start a new chat

  // State for handling replanning requests from background agents
  private replanRequested: boolean = false;
  private replanReason: string = '';
  private replanNewContextData: any = null;

  constructor(
      context: vscode.ExtensionContext,
      private modelManager: ModelManager,
      private orchestrator: Orchestrator,
      private globalContext: GlobalContext,
      private sessionContext: SessionContext,
      private agentOrchestratorService: AgentOrchestratorService // Dependency on AgentOrchestratorService
  ) {
    this.repository = new ChatRepository(context);
    this.setupAgentOrchestratorListeners(); // Setup listener for replan event
    console.log('[ChatService] Initialized');
  }

  /**
   * Sets up listeners for events from the AgentOrchestratorService.
   * @private
   */
  private setupAgentOrchestratorListeners(): void {
      // Listen for replan suggestions from the background agent orchestrator
      const listener = this.agentOrchestratorService.on('replanSuggested', (chatId, reason, newContextData) => {
          // Only set the flag if the suggested replan is for the current active chat
          if (this.currentChatId === chatId) {
              console.log(`[ChatService:${chatId}] Replan suggested by agent orchestrator: ${reason}`);
              this.replanRequested = true;
              this.replanReason = reason;
              this.replanNewContextData = newContextData;
              // Note: The planning loop in sendMessage checks this flag after each orchestrator call.
          } else {
              console.log(`[ChatService] Replan suggested for inactive chat ${chatId}. Ignoring.`);
          }
      });
      // Add this listener to the extension's subscriptions for automatic disposal
      // This is handled in extension.ts where ChatService is added to subscriptions.
      // If ChatService had its own disposables array, we'd add it there.
  }


  /**
   * Gets the ID of the currently active conversation.
   * @returns The current chat ID or null if no chat is active.
   */
  public getCurrentConversationId(): string | null {
    return this.currentChatId;
  }

  /**
   * Creates a new conversation in the database.
   * Also creates a new ConversationContext in memory and sets it as current.
   * @param title The title for the new conversation.
   * @returns The newly created Chat entity.
   */
  public async createConversation(title: string = 'New Conversation'): Promise<Chat> {
    const chat: Chat = {
      id: '', // ID will be generated by the repository
      title,
      timestamp: Date.now()
    };

    const newChat = await this.repository.create(chat);

    // Create a new ConversationContext for the new chat
    const convContext = new ConversationContext(newChat.id, this.sessionContext, []);
    this.activeConversations.set(newChat.id, convContext);
    this.currentChatId = newChat.id;
    this.pendingNewChat = false; // No longer pending a new chat, one is created

    console.log(`[ChatService] Created new chat: ${newChat.id}`);

    // Add the new context to the Orchestrator (if Orchestrator needs to track them)
    // Note: Orchestrator currently takes contexts via processUserMessage/FlowContext.
    // If Orchestrator needs a list of all active conv contexts, add a method here.
    // For now, Orchestrator primarily interacts via the FlowContext passed to processUserMessage.
    // Let's keep the Orchestrator.addConversationContext call from the original code.
    this.orchestrator.addConversationContext(convContext);


    return newChat;
  }

  /**
   * Prepares the service for a new conversation.
   * Does not save to DB until the first message is sent.
   */
  public prepareNewConversation(): void {
    // Clear the current chat ID and set the flag to create a new one on the next message
    this.currentChatId = null;
    this.pendingNewChat = true;
    console.log('[ChatService] Prepared for new chat state.');
  }

  /**
   * Gets all conversations from the database, ordered by timestamp.
   * Used for displaying the chat history list in the UI.
   * @returns An array of Chat entities.
   */
  public async getConversations(): Promise<Chat[]> {
    const chats = await this.repository.findAll();
    console.log(`[ChatService] Retrieved ${chats.length} chats from DB.`);
    return chats;
  }

  /**
   * Loads a specific conversation and its messages from the database.
   * Creates or retrieves the ConversationContext in memory and sets it as current.
   * @param chatId The ID of the conversation to load.
   * @returns An array of ChatMessage entities for the loaded conversation.
   */
  public async loadConversation(chatId: string): Promise<ChatMessage[]> {
    console.log(`[ChatService] Loading chat ${chatId}...`);

    let convContext = this.activeConversations.get(chatId);

    if (!convContext) {
        // If context not in memory, load from DB
        const chat = await this.repository.findById(chatId);
        if (!chat) {
          const error = new Error(`Conversation with ID ${chatId} not found in DB.`);
          console.error('[ChatService]', error.message);
          throw error;
        }

        const messages = await this.repository.getMessages(chatId);
        console.log(`[ChatService] Loaded chat ${chatId} from DB with ${messages.length} messages.`);

        // Create a new ConversationContext
        convContext = new ConversationContext(chatId, this.sessionContext, messages);
        this.activeConversations.set(chatId, convContext);
        this.orchestrator.addConversationContext(convContext); // Add to Orchestrator's tracking if needed

    } else {
         console.log(`[ChatService] Chat ${chatId} context found in memory.`);
    }

    // Set the loaded chat as the current one
    this.currentChatId = chatId;
    this.pendingNewChat = false; // No longer pending a new chat

    // Return messages from the context
    return convContext.getHistory();
  }

  /**
   * Updates a conversation's title in the database.
   * @param chatId The ID of the conversation.
   * @param title The new title.
   */
  public async updateConversationTitle(chatId: string, title: string): Promise<void> {
    console.log(`[ChatService] Updating title for chat ${chatId} to "${title}" in DB.`);
    return this.repository.updateTitle(chatId, title);
  }

  /**
   * Deletes a conversation from the database and removes its context from memory.
   * If the deleted chat was the current one, prepares for a new chat state.
   * @param chatId The ID of the conversation to delete.
   */
  public async deleteConversation(chatId: string): Promise<void> {
    console.log(`[ChatService] Deleting chat ${chatId}`);
    await this.repository.delete(chatId);

    // Dispose and remove the context from memory
    const convContext = this.activeConversations.get(chatId);
    if (convContext) {
        convContext.dispose();
        this.activeConversations.delete(chatId);
        console.log(`[ChatService] Chat ${chatId} context removed from memory.`);
        // Also remove from Orchestrator's tracking if needed
        this.orchestrator.clearConversationContext(chatId);
    }

    // If the deleted chat was the current one, prepare for a new chat
    if (this.currentChatId === chatId) {
      this.currentChatId = null;
      this.pendingNewChat = true;
      console.log('[ChatService] Deleted active chat, preparing new chat state.');
    }
  }

  /**
   * Ensures that a chat exists and is set as the current one.
   * If no chat is current or a new chat is pending, creates a new one.
   * @returns The ID of the current chat.
   */
  private async ensureChat(): Promise<string> {
    if (this.currentChatId && !this.pendingNewChat) {
      console.log(`[ChatService] Using existing chat ID ${this.currentChatId}`);
      return this.currentChatId;
    }

    console.log('[ChatService] Creating a new chat.');
    const newChat = await this.createConversation();
    return newChat.id;
  }


  /**
   * Sends a message in the current conversation.
   * Manages the planning/replanning loop and interacts with the Orchestrator and background agents.
   * @param text The user's message content.
   * @param files Optional array of file paths referenced by the user.
   * @returns The assistant's final response message.
   */
  public async sendMessage(text: string, files?: string[]): Promise<ChatMessage> {
    const chatId = await this.ensureChat();
    const convContext = this.activeConversations.get(chatId);

    if (!convContext) {
        // This should not happen if ensureChat is called first, but as a safeguard:
        throw new Error(`Failed to get ConversationContext for chat ID: ${chatId} after ensuring chat.`);
    }

    // 1. Save user message to DB and in-memory context
    const userMessage: ChatMessage = {
      id: '', // ID will be generated by the repository
      chatId,
      content: text,
      sender: 'user',
      timestamp: Date.now(),
      files: files || [] // Store referenced files with the message
    };
    const savedUserMessage = await this.repository.addMessage(userMessage);
    convContext.addMessage(savedUserMessage); // Add to in-memory context history

    // 2. Start the planning/replanning loop
    let assistantResponseContent: string | any = "Sorry, I couldn't complete the task.";
    let attempts = 0;
    let planningFinished = false;

    // Reset replan flags at the very start of a new user turn's processing
    this.replanRequested = false;
    this.replanReason = '';
    this.replanNewContextData = null;

    while (!planningFinished && attempts < MAX_PLANNING_ATTEMPTS) {
        attempts++;
        console.log(`[ChatService:${chatId}] Planning attempt ${attempts}/${MAX_PLANNING_ATTEMPTS}.`);

        // <-- Retrieve relevant memory for the current planning attempt
        // This is done at the start of *each* attempt to ensure the planner
        // has access to the latest memory, potentially updated by background agents.
        let retrievedMemory: MemoryItem[] = [];
        try {
            retrievedMemory = await this.agentOrchestratorService.getMemoryForTurn(convContext);
            // Store retrieved memory in the ConversationContext so FlowContext can pick it up
            convContext.setRetrievedMemory(retrievedMemory); // Assuming setRetrievedMemory exists on ConvContext
        } catch (error) {
            console.error('[ChatService] Error retrieving memory for turn:', error);
            // Continue without memory if retrieval fails, but log the error.
            convContext.setRetrievedMemory(undefined); // Clear potentially stale memory on error
        }
        // -->

        // 3. Create a new FlowContext for this planning attempt
        // The new FlowContext will inherit state from ConversationContext (summary, relevantFiles, analyzedFileInsights, retrievedMemory)
        const flowContext = convContext.createFlowContext();
        flowContext.setValue('userMessage', text); // The initial user message for the turn
        flowContext.setValue('referencedFiles', files || []); // The initial referenced files

        // <-- Add replanning specific data to FlowContext if this attempt is a replan
        if (attempts > 1 && this.replanRequested) {
             // Only add replan data if a replan was requested *before* this attempt started.
             flowContext.setValue('isReplanning', true);
             flowContext.setValue('replanReason', this.replanReason);
             flowContext.setValue('replanData', this.replanNewContextData);
             console.log(`[ChatService:${chatId}] Attempt ${attempts} is a replan. Reason: ${this.replanReason}`);
             // Reset replan flags *after* transferring the data to the new context
             this.replanRequested = false;
             this.replanReason = '';
             this.replanNewContextData = null;
        } else if (attempts > 1) {
             // If it's attempt > 1 but replan wasn't requested, it means the Orchestrator loop
             // in the previous attempt finished *without* choosing 'respond' and *without*
             // an agent requesting a replan. This is an unexpected state.
             console.warn(`[ChatService:${chatId}] Attempt ${attempts} starting without replan requested. Orchestrator loop may have finished unexpectedly in previous attempt.`);
             planningFinished = true; // Stop planning to prevent infinite loop
             // Set a default failure message if none was produced
             assistantResponseContent = assistantResponseContent === "Sorry, I couldn't complete the task."
                ? `Sorry, the planning process did not finalize with a response after attempt ${attempts-1}.`
                : assistantResponseContent; // Keep last partial response if any was set
             break; // Exit the planning loop
        }
        // -->


        // Ensure project info is fetched/available in GlobalContext via SessionContext
        // This is important context for the planner and agents.
        await this.sessionContext.getOrFetchProjectInfo();

        // 4. Process the turn with the Orchestrator for this planning attempt
        // The orchestrator runs its internal loop (planner -> executor -> planner...)
        // until the planner decides to 'respond' or hits its own internal max iterations.
        // If the orchestrator's internal loop finishes successfully with 'respond',
        // processUserMessage returns the response content.
        // If an error occurs *within* the orchestrator's loop, it throws an error.
        // If the orchestrator's internal loop hits its max iterations without 'respond',
        // it might return a default failure message or throw, depending on its implementation.
        try {
             assistantResponseContent = await this.orchestrator.processUserMessage(flowContext);

             // If processUserMessage returns a value, it implies the planner chose 'respond'.
             planningFinished = true; // Mark planning as successfully completed.
             console.log(`[ChatService:${chatId}] Planning finished successfully after ${attempts} attempts.`);

        } catch (error: any) {
             // If an error occurs during the orchestrator's process...
             console.error(`[ChatService:${chatId}] Orchestrator processUserMessage failed during attempt ${attempts}:`, error);
             // Check if a replan was requested by an agent *during* this failed attempt.
             if (this.replanRequested && attempts < MAX_PLANNING_ATTEMPTS) {
                  console.log(`[ChatService:${chatId}] Replan requested during failed attempt ${attempts}. Retrying...`);
                  // The loop condition will be true, and it will proceed to the next attempt.
                  // The replan flags were already set by the agent orchestrator listener.
             } else {
                  // If no replan was requested, or we've reached max attempts...
                  console.error(`[ChatService:${chatId}] Planning failed after ${attempts} attempts and no replan requested or max attempts reached.`);
                  planningFinished = true; // Stop planning.
                  // Set a failure message including the error.
                  assistantResponseContent = `Sorry, an error occurred during the planning process after ${attempts} attempts: ${error.message || String(error)}`;
             }
        }

        // The loop condition `!planningFinished && attempts < MAX_PLANNING_ATTEMPTS`
        // correctly manages whether to continue to the next attempt or exit the loop.
        // If `planningFinished` becomes true (either by successful 'respond' or error handling), the loop stops.
        // If `attempts` reaches `MAX_PLANNING_ATTEMPTS`, the loop stops.
    }

    // If the loop finished because max attempts were reached without planningFinished being set by 'respond'
    if (!planningFinished) {
         console.warn(`[ChatService:${chatId}] Planning loop exited after ${attempts} attempts without finalizing 'respond'.`);
         // assistantResponseContent should already be set by the last attempt's error handling or default.
         if (assistantResponseContent === "Sorry, I couldn't complete the task.") {
             // Fallback message if no specific error message was set
             assistantResponseContent = `Sorry, the planning process could not be finalized after ${MAX_PLANNING_ATTEMPTS} attempts.`;
         }
    }


    // 5. Save and return the assistant's final response message
    const assistantMessage: ChatMessage = {
      id: '', // ID will be generated by the repository
      chatId,
      content: typeof assistantResponseContent === 'string' ? assistantResponseContent : JSON.stringify(assistantResponseContent), // Ensure content is string
      sender: 'assistant',
      timestamp: Date.now(),
      files: [] // Assistant responses typically don't add files this way
    };
    const savedAssistantMessage = await this.repository.addMessage(assistantMessage);
    convContext.addMessage(savedAssistantMessage); // Add to in-memory context history

    // 6. Trigger background processing AFTER the turn is fully complete and messages are saved.
    // This allows agents to process the *latest* state of the conversation.
    this.agentOrchestratorService.triggerProcessing(convContext);

    // Return the final saved message
    return savedAssistantMessage;
  }

   /**
    * Disposes of resources used by the ChatService.
    * Removes event listeners to prevent memory leaks.
    */
   dispose(): void {
        console.log('[ChatService] Disposing.');
        // Remove the listener from the AgentOrchestratorService
        // Note: If AgentOrchestratorService is disposed *before* ChatService, this might throw.
        // Ensure disposal order in extension.ts (AgentOrchestratorService after ChatService, or ChatService listener removed first).
        // The current extension.ts disposes AgentOrchestratorService *before* PromptSystem (which disposes ModelManager).
        // ChatService is added to subscriptions, so its dispose is called when the extension deactivates.
        // AgentOrchestratorService is also added to subscriptions. The order they are added to subscriptions
        // determines the disposal order (last added is disposed first).
        // To ensure AgentOrchestratorService is disposed *after* ChatService (so ChatService can remove its listener),
        // add AgentOrchestratorService to subscriptions *before* ChatService in extension.ts.
        // Let's add the listener removal here anyway as a safeguard.
        this.agentOrchestratorService.removeAllListeners('replanSuggested');

        // Dispose of active ConversationContexts
        this.activeConversations.forEach(context => context.dispose());
        this.activeConversations.clear();

        // Reset state variables
        this.currentChatId = null;
        this.pendingNewChat = false;
        this.replanRequested = false;
        this.replanReason = '';
        this.replanNewContextData = null;

        // The repository and other injected services are disposed by extension.ts
   }
}