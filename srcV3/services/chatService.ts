import * as vscode from 'vscode';
import { IChatRepository } from '../storage/interfaces/IChatRepository';
import { ChatRepository } from '../storage/repositories/chatRepository';
import { Chat, ChatMessage } from '../storage/interfaces/entities';
import { ModelManager } from '../models/config/ModelManager';
import { Orchestrator } from '../orchestrator/orchestrator';
// Remove getProjectInfo import if sessionContext handles it or orchestrator gets it
// import { getProjectInfo } from '../modules/getProjectInfo'; // Keep for now, refactor later

// Import context classes
import { GlobalContext, SessionContext, ConversationContext, FlowContext } from '../orchestrator/context';


/**
 * Service for managing conversation interactions and integrating the AI model.
 * This service orchestrates the steps of a chat turn.
 */
export class ChatService {
  private repository: IChatRepository;
  // ChatService now manages ConversationContexts in memory keyed by chatId
  private activeConversations: Map<string, ConversationContext> = new Map();
  private currentChatId: string | null = null;
  private pendingNewChat: boolean = false;

  // ChatService now depends on ModelManager, Orchestrator, and context layers
  constructor(
      context: vscode.ExtensionContext,
      private modelManager: ModelManager,
      private orchestrator: Orchestrator,
      private globalContext: GlobalContext, // Reference to GlobalContext
      private sessionContext: SessionContext // Reference to SessionContext
  ) {
    this.repository = new ChatRepository(context);
    console.log('[ChatService] Initialized with context references.');
  }

  // Helper to get the active ConversationContext
  private getActiveConversationContext(): ConversationContext | null {
      if (!this.currentChatId) return null;
      return this.activeConversations.get(this.currentChatId) || null;
  }

  /**
   * Creates a new conversation (saves to DB)
   */
  public async createConversation(title: string = 'New Conversation'): Promise<Chat> {
    // Create DB entry
    const chat: Chat = {
      id: '',  // Will be generated by repository
      title,
      timestamp: Date.now()
    };

    const newChat = await this.repository.create(chat);

    // Create in-memory ConversationContext for the new chat
    const convContext = new ConversationContext(newChat.id, this.sessionContext, []);
    this.activeConversations.set(newChat.id, convContext);
    this.currentChatId = newChat.id;
    this.pendingNewChat = false; // No longer pending

    console.log(`[ChatService] Created new chat: ${newChat.id}. In-memory context created.`);

    // Signal orchestrator about the new conversation context
    this.orchestrator.addConversationContext(convContext);

    return newChat;
  }

  /**
   * Prepares the service for a new conversation (doesn't save until first message).
   * Resets current chat state.
   */
  public prepareNewConversation(): void {
    // Clear the current active chat context reference
    this.currentChatId = null;
    this.pendingNewChat = true;
    console.log('[ChatService] Prepared for new chat state.');
    // Note: The in-memory ConversationContext for the previous chat persists
    // in the map until another chat is loaded or it's explicitly removed/disposed (e.g., on extension deactivate).
  }

  /**
   * Gets all conversations (from DB for UI list)
   */
  public async getConversations(): Promise<Chat[]> {
    const chats = await this.repository.findAll();
    console.log(`[ChatService] Retrieved ${chats.length} chats from DB.`);
    return chats;
  }

  /**
   * Loads a specific conversation and its messages
   */
  public async loadConversation(chatId: string): Promise<ChatMessage[]> {
    console.log(`[ChatService] Attempting to load chat ${chatId}...`);

    // Check if conversation context is already in memory
    let convContext = this.activeConversations.get(chatId);

    if (!convContext) {
        // If not in memory, load messages from DB
        const chat = await this.repository.findById(chatId);
        if (!chat) {
          const error = new Error(`Conversation with ID ${chatId} not found in DB.`);
          console.error('[ChatService]', error.message);
          throw error;
        }

        const messages = await this.repository.getMessages(chatId);
        console.log(`[ChatService] Loaded chat ${chatId} from DB with ${messages.length} messages.`);

        // Create in-memory ConversationContext and add messages
        convContext = new ConversationContext(chatId, this.sessionContext, messages);
        this.activeConversations.set(chatId, convContext);

        // Signal orchestrator about the loaded conversation context
        this.orchestrator.addConversationContext(convContext);

    } else {
         console.log(`[ChatService] Chat ${chatId} context found in memory.`);
         // Messages should already be in the in-memory context, but double-check/refresh from DB if needed?
         // For simplicity in Stage 1, trust the in-memory version if it exists.
    }

    this.currentChatId = chatId;
    this.pendingNewChat = false;

    return convContext.getHistory(); // Return messages from the loaded context
  }

  /**
   * Updates a conversation's title (in DB)
   */
  public async updateConversationTitle(chatId: string, title: string): Promise<void> {
    console.log(`[ChatService] Updating title for chat ${chatId} to "${title}" in DB.`);
    return this.repository.updateTitle(chatId, title);
    // Note: In-memory context title won't be updated automatically.
    // If the UI needs the title, it should fetch the chat list again or
    // the ConversationContext could store the title and be updated here.
    // Let's add title to ConversationContext state.
    const convContext = this.activeConversations.get(chatId);
    if (convContext) {
        // Assuming Chat interface gets a title property eventually sync'd with DB
        // For now, no title in ConversationContextState, just chatId and messages.
    }
  }

  /**
   * Deletes a conversation (from DB and memory)
   */
  public async deleteConversation(chatId: string): Promise<void> {
    console.log(`[ChatService] Deleting chat ${chatId} from DB and memory.`);
    // Delete from DB first
    await this.repository.delete(chatId);

    // Dispose and remove from in-memory map
    const convContext = this.activeConversations.get(chatId);
    if (convContext) {
        convContext.dispose();
        this.activeConversations.delete(chatId);
         console.log(`[ChatService] Chat ${chatId} context removed from memory.`);
         // Signal orchestrator to clear its reference too
         this.orchestrator.clearConversationContext(chatId);
    }


    if (this.currentChatId === chatId) {
      this.currentChatId = null;
      this.pendingNewChat = true; // Prepare for a new chat after deleting the active one
      console.log('[ChatService] Deleted active chat, preparing new chat state.');
    }
  }

  /**
   * Gets the current conversation ID
   */
  public getCurrentConversationId(): string | null {
    return this.currentChatId;
  }


  /**
   * Sends a message in the current conversation
   */
  public async sendMessage(text: string, files?: string[]): Promise<ChatMessage> {
    // Ensure we have a current chat ID. If pending, create a new one.
    const chatId = await this.ensureChat();
    const convContext = this.activeConversations.get(chatId);

    if (!convContext) {
        // This should ideally not happen if ensureChat runs correctly
        throw new Error(`Failed to get ConversationContext for chat ID: ${chatId}`);
    }

    // 1. Save user message to DB
    const userMessage: ChatMessage = {
      id: '', // Repository will generate
      chatId,
      content: text,
      sender: 'user',
      timestamp: Date.now(),
      files: files || []
    };

    const savedUserMessage = await this.repository.addMessage(userMessage);

    // Add saved user message to the in-memory ConversationContext
    convContext.addMessage(savedUserMessage);

    // 2. Create a new FlowContext for this turn and add initial user data
    const flowContext = convContext.createFlowContext();
    flowContext.setValue('userMessage', text); // Store the user's message in flow context
    flowContext.setValue('referencedFiles', files || []); // Store referenced files in flow context

    // Fetch project info and store it in GlobalContext via SessionContext
    // We do this here or in SessionContext constructor to ensure it's available in context
    const projectInfo = await this.sessionContext.getOrFetchProjectInfo();
    // No need to explicitly set projectInfo in flowContext/convContext anymore,
    // getResolutionContext in FlowContext will get it from GlobalContext

    // 3. Process with orchestrator (passing the FlowContext)
    // The orchestrator.processUserMessage will now receive the FlowContext
    // It will perform analysis, handler selection, and step execution using this context.
    // It should eventually return the final string content for the assistant's message.
    const assistantResponseContent = await this.orchestrator.processUserMessage(flowContext);

    // 4. Save and return assistant's response message
    const assistantMessage: ChatMessage = {
      id: '', // Repository will generate
      chatId,
      // Ensure the content is a string. Orchestrator should handle this.
      content: typeof assistantResponseContent === 'string' ? assistantResponseContent : JSON.stringify(assistantResponseContent),
      sender: 'assistant',
      timestamp: Date.now(),
      files: [] // Assistant messages typically don't add files directly
    };

    const savedAssistantMessage = await this.repository.addMessage(assistantMessage);

    // Add saved assistant message to the in-memory ConversationContext
    convContext.addMessage(savedAssistantMessage);


    return savedAssistantMessage; // Return the full saved message object
  }

  /**
   * Ensures there is a current chat ID, creating a new one if needed.
   * @returns The current chat ID.
   */
  private async ensureChat(): Promise<string> {
    if (this.currentChatId && !this.pendingNewChat) {
      console.log(`[ChatService] Current chat ID is ${this.currentChatId}. Using it.`);
      return this.currentChatId;
    }

    console.log('[ChatService] No active chat, creating a new one.');
    const newChat = await this.createConversation(); // createConversation handles setting currentChatId and pendingNewChat=false
    return newChat.id;
  }

   /**
    * Disposes of all active ConversationContexts held in memory.
    * Called on extension deactivate.
    */
   dispose(): void {
        console.log('[ChatService] Disposing all active conversation contexts.');
        this.activeConversations.forEach(context => context.dispose());
        this.activeConversations.clear();
        this.currentChatId = null;
        this.pendingNewChat = false;
   }
}