import * as vscode from 'vscode';
import { IChatRepository } from '../storage/interfaces/IChatRepository';
import { ChatRepository } from '../storage/repositories/chatRepository';
import { Chat, ChatMessage } from '../storage/models/entities';
import { ModelManager } from '../models/config/ModelManager';
import { Orchestrator } from '../orchestrator/orchestrator'; // Replace OrchestratorService import
import { getProjectInfo } from '../modules/getProjectInfo';

/**
 * Service for managing conversation interactions and integrating the AI model.
 * This service orchestrates the steps of a chat turn.
 */
export class ChatService {
  private repository: IChatRepository;
  private currentChatId: string | null = null;
  private pendingNewChat: boolean = false;
  
  // ChatService now depends on ModelManager and Orchestrator
  constructor(context: vscode.ExtensionContext, private modelManager: ModelManager, private orchestrator: Orchestrator) {
    this.repository = new ChatRepository(context);
  }
  
  /**
   * Creates a new conversation (saves to DB)
   */
  public async createConversation(title: string = 'New Conversation'): Promise<Chat> {
    const chat: Chat = {
      id: '',  // Will be generated by repository
      title,
      timestamp: Date.now()
    };
    
    const newChat = await this.repository.create(chat);
    this.currentChatId = newChat.id;
    this.pendingNewChat = false;
    console.log(`[ChatService] Created new chat: ${newChat.id}`);
    return newChat;
  }
  
  /**
   * Prepares the service for a new conversation (doesn't save until first message).
   * Resets current chat state.
   */
  public prepareNewConversation(): void {
    this.currentChatId = null;
    this.pendingNewChat = true;
    console.log('[ChatService] Prepared for new chat');
  }
  
  /**
   * Gets all conversations
   */
  public async getConversations(): Promise<Chat[]> {
    const chats = await this.repository.findAll();
    console.log(`[ChatService] Retrieved ${chats.length} chats`);
    return chats;
  }
  
  /**
   * Loads a specific conversation and its messages
   */
  public async loadConversation(chatId: string): Promise<ChatMessage[]> {
    const chat = await this.repository.findById(chatId);
    if (!chat) {
      const error = new Error(`Conversation with ID ${chatId} not found`);
      console.error('[ChatService]', error.message);
      throw error;
    }
    
    this.currentChatId = chatId;
    this.pendingNewChat = false;
    const messages = await this.repository.getMessages(chatId);
    console.log(`[ChatService] Loaded chat ${chatId} with ${messages.length} messages`);
    return messages;
  }
  
  /**
   * Updates a conversation's title
   */
  public async updateConversationTitle(chatId: string, title: string): Promise<void> {
    console.log(`[ChatService] Updating title for chat ${chatId} to "${title}"`);
    return this.repository.updateTitle(chatId, title);
  }
  
  /**
   * Deletes a conversation
   */
  public async deleteConversation(chatId: string): Promise<void> {
    console.log(`[ChatService] Deleting chat ${chatId}`);
    if (this.currentChatId === chatId) {
      this.currentChatId = null;
      this.pendingNewChat = true; // Prepare for a new chat after deleting the active one
      console.log('[ChatService] Deleted active chat, preparing new chat state');
    }
    return this.repository.delete(chatId);
  }
  
  /**
   * Gets the current conversation ID
   */
  public getCurrentConversationId(): string | null {
    return this.currentChatId;
  }
  
  /**
   * Gets the current chat ID
   */
  public getCurrentChatId(): string | null {
    return this.currentChatId;
  }
  
  /**
   * Sends a message in the current conversation
   */
  public async sendMessage(text: string, files?: string[]): Promise<ChatMessage> {
    const chatId = await this.ensureChat();

    // 1. Guardar mensaje usuario
    const userMessage = {
      id: '',
      chatId,
      content: text,
      sender: 'user' as const,
      timestamp: Date.now(),
      files: files || []
    };

    const savedUserMessage = await this.repository.addMessage(userMessage);

    const projectInfo = await getProjectInfo();
    const messageHistory = await this.repository.getMessages(chatId); // Get full history for context

    // 2. Procesar con orquestador (pasando chatId e historial)
    // The orchestrator.processUserMessage should return the string content
    // for the assistant's chat message. Any complex results (like diffs)
    // should be stored by the handler in the InteractionContext for the UI to read.
    const assistantResponseContent = await this.orchestrator.processUserMessage(chatId, text, files, projectInfo, messageHistory);

    // 3. Guardar y retornar respuesta del asistente
    const assistantMessage = {
      id: '',
      chatId,
      // Ensure the content is a string. Orchestrator should handle this,
      // but a final check here is safe.
      content: typeof assistantResponseContent === 'string' ? assistantResponseContent : JSON.stringify(assistantResponseContent), // Fallback to stringify if not string
      sender: 'assistant' as const,
      timestamp: Date.now(),
      // Files might be associated with the assistant message if the handler
      // indicates it (e.g., "Here is the modified file:"), but typically
      // files are associated with the user's input or referenced in the content.
      // For now, let's not copy user files to assistant message unless needed.
      files: [] // Or potentially files referenced *by the assistant* if the handler provides them
    };

    return this.repository.addMessage(assistantMessage);
  }
  
  /**
   * Saves a message to the repository
   */
  public async saveMessage(message: ChatMessage): Promise<ChatMessage> {
    return this.repository.addMessage(message);
  }
  
  private async ensureChat(): Promise<string> {
    if (!this.currentChatId) {
      const newChat = await this.createConversation();
      return newChat.id;
    }
    return this.currentChatId;
  }
}