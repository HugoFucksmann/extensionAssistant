// src/services/ConversationManager.ts

import { ChatPersistenceService } from '../store/services/ChatPersistenceService'; // Dependency
import { ConversationService } from '../contextServices/ConversationService'; // Dependency for in-memory state management
import { OrchestratorService } from '../orchestrator/OrchestratorService'; // Dependency for orchestration
import { Chat, ChatMessage } from '../store/interfaces/entities'; // Need ChatMessage type

/**
 * Manages the business logic flow for conversations.
 * Coordinates persistence, in-memory state, and orchestration for a chat turn.
 */
export class ConversationManager {
    private chatPersistenceService: ChatPersistenceService;
    private conversationService: ConversationService; // Manages active conversation states
    private orchestratorService: OrchestratorService; // Executes the AI workflow (LangGraph)

    // Keep track of the current active chat ID for the UI, managed by ChatInteractor
    private activeChatId: string | null = null;
    private pendingNewChat: boolean = false; // Flag for starting a new chat on next message


    constructor(
        chatPersistenceService: ChatPersistenceService,
        conversationService: ConversationService,
        orchestratorService: OrchestratorService
    ) {
        this.chatPersistenceService = chatPersistenceService;
        this.conversationService = conversationService;
        this.orchestratorService = orchestratorService;
        console.log('[ConversationManager] Initialized.');
    }

    /**
     * Handles sending a user message, coordinating the full turn lifecycle:
     * Save user message -> Run orchestration (LangGraph) -> Save assistant response.
     * @param chatId The ID of the current chat, or null/undefined for a new chat.
     * @param text The user's message content.
     * @param files Files referenced by the user.
     * @returns A Promise resolving to the final assistant message entity.
     */
    async sendMessage(chatId: string | null, text: string, files: string[] = []): Promise<ChatMessage> {
        // Determine the actual chatId for this turn
        let currentChatId = chatId;

        if (this.pendingNewChat || currentChatId === null || currentChatId === 'temp-new-chat') {
             console.log('[ConversationManager] Starting a new conversation.');
             const newChat = await this.chatPersistenceService.createConversation();
             currentChatId = newChat.id;
             this.pendingNewChat = false; // Reset flag
             this.activeChatId = currentChatId; // Set the new chat as active

             // Ensure the new conversation state is added to ConversationService's active map
             // The createConversation in ChatPersistenceService emits 'chatCreated',
             // which ConversationService should listen to and add to its map.
             // Or, call ConversationService.createConversation directly here?
             // Let's update ConversationService.createConversation to also manage the in-memory map.
             // Or simply rely on getConversation below to load it into memory.
        } else {
            this.activeChatId = currentChatId; // Confirm active chat
            console.log(`[ConversationManager] Continuing conversation ${currentChatId}.`);
        }

         // Ensure the conversation is loaded into memory for the turn
         const conversationState = await this.conversationService.getConversation(currentChatId);
         if (!conversationState) {
              // This should not happen if createConversation or getConversation worked
               throw new Error(`Failed to get or create conversation state for ID: ${currentChatId}`);
         }


        // 1. Save user message to persistence and in-memory state
        const userMessage: ChatMessage = {
            id: '', // ID will be generated by persistence service
            chatId: currentChatId,
            content: text,
            sender: 'user',
            timestamp: Date.now(),
            files: files || [] // Store referenced files with the message
        };
        // addMessageToConversationState handles both persistence and in-memory update
        const savedUserMessage = await this.conversationService.addMessageToConversationState(currentChatId, userMessage);


        // 2. Run the orchestration workflow for this turn
        // The orchestrator will update the FlowContextState (LangGraph state)
        // and use other services (Prompt, Tool, TurnState, etc.).
        // The orchestrator returns the final message content decided by the graph.
        const assistantResponseContent = await this.orchestratorService.runTurn(
            currentChatId,
            text, // Pass user message content
            files // Pass referenced files
            // OrchestratorService uses TurnStateService which uses ConversationService
            // to get necessary context state like history, etc.
        );


        // 3. Save assistant's response message to persistence and in-memory state
        const assistantMessage: ChatMessage = {
            id: '', // ID will be generated by persistence service
            chatId: currentChatId,
            content: typeof assistantResponseContent === 'string' ? assistantResponseContent : JSON.stringify(assistantResponseContent), // Ensure content is string
            sender: 'assistant',
            timestamp: Date.now(),
            files: [] // Assistant responses typically don't reference files in the same way
        };
         // addMessageToConversationState handles both persistence and in-memory update
        const savedAssistantMessage = await this.conversationService.addMessageToConversationState(currentChatId, assistantMessage);


        console.log(`[ConversationManager] Turn completed for chat ${currentChatId}.`);
        return savedAssistantMessage; // Return the saved assistant message entity
    }

     /**
      * Prepares the manager for starting a new chat on the next message.
      */
     prepareNewConversation(): void {
         this.pendingNewChat = true;
         this.activeChatId = null; // Clear active chat ID to signal a new chat
         console.log('[ConversationManager] Prepared state for new conversation.');
     }

     /**
      * Gets the current active conversation ID.
      * This is primarily for the UI to know which chat is displayed.
      */
     getActiveChatId(): string | null {
         // If pending new chat, return a temporary ID for UI purposes
          return this.pendingNewChat ? 'temp-new-chat' : this.activeChatId;
     }


     // Methods to delegate to persistence service or conversation service
     // These are higher-level business logic if needed, otherwise ChatInteractor
     // can call persistence/conversation services directly.
     // Keeping them here as they are part of the "conversation business domain".

     async getConversations(): Promise<Chat[]> {
         return this.chatPersistenceService.getConversations();
     }

     async loadConversation(chatId: string): Promise<ChatMessage[]> {
         // Load into memory via ConversationService (which uses PersistenceService)
         const conversationState = await this.conversationService.getConversation(chatId);
          if (!conversationState) {
              throw new Error(`Conversation with ID ${chatId} not found.`);
          }
         this.activeChatId = chatId; // Set as active after loading
         this.pendingNewChat = false; // Not a new chat

         // Return messages from the loaded state
         return conversationState.messages;
     }

     async deleteConversation(chatId: string): Promise<void> {
         await this.conversationService.deleteConversation(chatId); // Service handles both memory and persistence deletion + event
         if (this.activeChatId === chatId) {
             this.prepareNewConversation(); // Prepare for a new chat if the active one was deleted
         }
     }

     async updateConversationTitle(chatId: string, title: string): Promise<void> {
         await this.chatPersistenceService.updateConversationTitle(chatId, title); // Persistence service handles DB update + event
     }

    dispose(): void {
        this.activeChatId = null;
        this.pendingNewChat = false;
         // Services it depends on are disposed by the ServiceFactory
        console.log('[ConversationManager] Disposed.');
    }
}