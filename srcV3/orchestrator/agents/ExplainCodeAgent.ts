// src/orchestrator/agents/ExplainCodeAgent.ts


import { FlowContext } from '../context/flowContext';
import { StepExecutor } from '../execution/stepExecutor';
import { ExecutionStep } from '../execution/types';
import { IAgent } from './IAgent';

/**
 * Agent responsible for handling 'explainCode' intents.
 * This agent follows a fixed sequence of steps:
 * 1. Get the relevant code content (from active editor or specified file).
 * 2. Run the 'explainCodePrompt' using the retrieved content.
 * 3. Return the explanation generated by the prompt.
 */
export class ExplainCodeAgent implements IAgent {
    private stepExecutor: StepExecutor;

    constructor(stepExecutor: StepExecutor) {
        this.stepExecutor = stepExecutor;
    }

    async execute(flowContext: FlowContext): Promise<string | any> {
        const chatId = flowContext.getChatId();
        const analysis = flowContext.getAnalysisResult();
        const objective = flowContext.getObjective() || 'Explain code';
        console.log(`[ExplainCodeAgent:${chatId}] Executing for objective: ${objective}`);

        // Determine which code to explain. Prioritize files mentioned in analysis,
        // otherwise use the active editor content.
        const filesMentioned = analysis?.extractedEntities?.filesMentioned || [];
        const targetFilePath = filesMentioned.length > 0 ? filesMentioned[0] : undefined; // Take the first mentioned file

        const steps: ExecutionStep[] = [];

        // Step 1: Get code content
        // Check if content is already in context (e.g., from a previous turn or analysis pre-fetch)
        const existingCodeContent = targetFilePath ? flowContext.getValue(`fileContent:${targetFilePath}`) : flowContext.getValue('activeEditorContent');

        if (existingCodeContent === undefined) { // Only add step if content is NOT already there
            if (targetFilePath) {
                 // TODO: Add validation if file exists/is accessible
                 steps.push({
                     name: 'getFileContentForExplanation',
                     type: 'tool',
                     execute: 'filesystem.getFileContents',
                     params: { filePath: targetFilePath },
                     storeAs: `fileContent:${targetFilePath}` // Store using a dynamic key
                 });
            } else {
                 // Fallback to active editor content if no file mentioned and content missing
                 steps.push({
                     name: 'getEditorContentForExplanation',
                     type: 'tool',
                     execute: 'editor.getActiveEditorContent',
                     storeAs: 'activeEditorContent'
                 });
            }
        } else {
             console.log(`[ExplainCodeAgent:${chatId}] Code content already available in context.`);
        }


        // Step 2: Run explainCodePrompt
        steps.push({
            name: 'runExplainCodePrompt',
            type: 'prompt',
            execute: 'explainCodePrompt',
            params: {}, // explainCodePrompt uses full context (including stored code content)
            storeAs: 'explanationResult',
             // Condition: Only run if *some* code content is available in the context
             condition: (ctx) => {
                  const codeContent = targetFilePath ? ctx[`fileContent:${targetFilePath}`] : ctx.activeEditorContent;
                  return codeContent !== undefined && codeContent !== null && codeContent !== '';
             }
        });

        let finalResponse: string | any = `Sorry, I couldn't explain the code. I might not have been able to access the code content or the explanation prompt failed.`; // Default failure message

        for (const step of steps) {
            const stepResult = await this.stepExecutor.runStep(step, flowContext);

            if (stepResult.skipped) {
                 console.log(`[ExplainCodeAgent:${chatId}] Step skipped: '${step.name}'. Condition was false.`);
                 // If a step is skipped, check if it was a critical step.
                 // If the 'get content' step was skipped because content was already there, that's fine.
                 // If the 'explain prompt' step was skipped because content wasn't available, the finalResponse will reflect that.
            } else if (!stepResult.success) {
                console.error(`[ExplainCodeAgent:${chatId}] Step failed: '${step.name}'.`, stepResult.error?.message || 'Unknown error');
                // If a step fails, set the final response to an error and stop the sequence
                finalResponse = `Sorry, a step failed while trying to explain the code ('${step.name}'). Error: ${stepResult.error?.message || 'Unknown error'}.`;
                return finalResponse; // Exit early
            } else {
                 console.log(`[ExplainCodeAgent:${chatId}] Step succeeded: '${step.name}'.`);
                 // If the last step (explainCodePrompt) succeeded, its result is the desired output
                 if (step.name === 'runExplainCodePrompt' && stepResult.result !== undefined) {
                      finalResponse = stepResult.result; // Assuming the prompt returns the explanation string directly
                 }
            }
        }

         // After running all steps, return the finalResponse.
         // If the explanation prompt succeeded, finalResponse will hold its result.
         // Otherwise, it will hold the default failure message or an error message from a failed step.
        return finalResponse;
    }
}