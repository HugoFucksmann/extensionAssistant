// src/orchestrator/agents/ConsoleAgent.ts

import { IAgent } from './IAgent';
import { FlowContext } from '../context/flowContext';
import { StepExecutor } from '../execution/stepExecutor';
import { ExecutionStep } from '../execution/types';

/**
 * Agent responsible for handling 'console' intents.
 * This agent formats a command based on the user's objective and runs it in a terminal.
 * Sequence:
 * 1. Get the command objective from analysis or context.
 * 2. Run the 'consoleCommandFormatter' prompt to get the command string.
 * 3. Run the 'terminal.runCommand' tool with the formatted command.
 * 4. Respond to the user confirming the command was run.
 */
export class ConsoleAgent implements IAgent {
    private stepExecutor: StepExecutor;

    constructor(stepExecutor: StepExecutor) {
        this.stepExecutor = stepExecutor;
    }

    async execute(flowContext: FlowContext): Promise<string | any> {
        const chatId = flowContext.getChatId();
        const analysis = flowContext.getAnalysisResult();
        // Get the command objective from the objective or user message
        const commandObjective = analysis?.objective || flowContext.getValue<string>('userMessage') || '';

        console.log(`[ConsoleAgent:${chatId}] Executing for command objective: "${commandObjective.substring(0, 50)}..."`);

        if (!commandObjective) {
            console.warn(`[ConsoleAgent:${chatId}] No command objective found.`);
            return "Sorry, I couldn't determine what command you want to run.";
        }

        const steps: ExecutionStep[] = [
            // Step 1: Format the command string using a prompt
            {
                name: 'formatConsoleCommand',
                type: 'prompt',
                execute: 'consoleCommandFormatter',
                params: {}, // consoleCommandFormatter prompt uses full context (including commandObjective)
                storeAs: 'commandString', // Store the generated command string
            },
            // Step 2: Run the command in the terminal
            {
                name: 'runTerminalCommand',
                type: 'tool',
                execute: 'terminal.runCommand',
                // Params need to reference the stored command string
                params: {
                    command: '{{commandString}}', // Use placeholder for the command string
                    // Optional: Add terminalName or showTerminal if needed, potentially from analysis or config
                    // terminalName: '{{extractedEntities.terminalName}}', // Example: if analysis extracts a terminal name
                    showTerminal: true // Default to showing the terminal
                },
                storeAs: 'commandResult', // Store the result of the tool execution (e.g., success status, command run)
                 // Condition: Only run if the command string was successfully generated by the prompt
                 // Check if commandString exists and is not null/undefined/empty string after trimming.
                 condition: (ctx) => {
                      const cmd = ctx.commandString;
                      return cmd !== undefined && cmd !== null && typeof cmd === 'string' && cmd.trim() !== '';
                 }
            }
        ];

        let finalResponse: string | any = "Sorry, I couldn't run the command."; // Default failure message

        for (const step of steps) {
            const stepResult = await this.stepExecutor.runStep(step, flowContext);

            if (stepResult.skipped) {
                 console.log(`[ConsoleAgent:${chatId}] Step skipped: '${step.name}'. Condition was false.`);
                 // If the run command step is skipped because commandString is missing,
                 // the finalResponse will remain the default failure message.
            } else if (!stepResult.success) {
                console.error(`[ConsoleAgent:${chatId}] Step failed: '${step.name}'.`, stepResult.error?.message || 'Unknown error');
                // If a step fails, set the final response to an error and stop the sequence
                finalResponse = `Sorry, a step failed while trying to run the command ('${step.name}'). Error: ${stepResult.error?.message || 'Unknown error'}.`;
                return finalResponse; // Exit early
            } else {
                 console.log(`[ConsoleAgent:${chatId}] Step succeeded: '${step.name}'.`);
                 // If the last step (runTerminalCommand) succeeded, we can formulate a success message
                 if (step.name === 'runTerminalCommand' && stepResult.result !== undefined) {
                      // Assuming the tool returns an object like { success: boolean, command: string, ... }
                      const commandRun = stepResult.result.command || flowContext.getValue('commandString');
                      finalResponse = `Successfully sent command \`${commandRun}\` to the terminal.`;
                 }
            }
        }

         // After running all steps, return the finalResponse.
         // If the command was run successfully, finalResponse will hold the success message.
         // Otherwise, it will hold the default failure message or an error message from a failed step.
        return finalResponse;
    }
}