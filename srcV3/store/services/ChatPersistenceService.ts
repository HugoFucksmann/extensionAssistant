// src/store/services/ChatPersistenceService.ts

import { IChatRepository } from "../interfaces/IChatRepository";
import { Chat, ChatMessage } from "../interfaces/entities";
import { EventEmitterService } from "../../events/EventEmitterService"; // Depend on EventEmitterService

/**
 * Service layer for Chat persistence.
 * Wraps the ChatRepository and adds business logic/event emission.
 */
export class ChatPersistenceService {
    constructor(
        private chatRepository: IChatRepository,
        private eventEmitter: EventEmitterService // Inject EventEmitterService
    ) {
         console.log('[ChatPersistenceService] Initialized.');
    }

    async createConversation(title: string = 'New Conversation'): Promise<Chat> {
        const chat: Chat = {
            id: '', // ID will be generated by repo
            title,
            timestamp: Date.now(),
            preview: '' // Initial empty preview
        };
        const newChat = await this.chatRepository.create(chat);
         this.eventEmitter.emit('chatCreated', newChat);
        return newChat;
    }

    async getConversations(): Promise<Chat[]> {
        return this.chatRepository.findAll();
    }

    async loadConversationMessages(chatId: string): Promise<ChatMessage[]> {
        const messages = await this.chatRepository.getMessages(chatId);
         this.eventEmitter.emit('chatMessagesLoaded', { chatId, messages });
        return messages;
    }

    async updateConversationTitle(chatId: string, title: string): Promise<void> {
        await this.chatRepository.updateTitle(chatId, title);
         this.eventEmitter.emit('chatTitleUpdated', { chatId, title });
    }

    async deleteConversation(chatId: string): Promise<void> {
        await this.chatRepository.delete(chatId);
         this.eventEmitter.emit('chatDeleted', { chatId });
    }

     async addMessageToConversation(message: ChatMessage): Promise<ChatMessage> {
         const savedMessage = await this.chatRepository.addMessage(message);

         // Add business logic: update chat timestamp and preview after adding a message
         await this.chatRepository.update(savedMessage.chatId, { timestamp: Date.now() });
         if (savedMessage.sender === 'user' && !savedMessage.chatId.startsWith('temp-')) { // Avoid updating preview for temp/unsaved chats
             const preview = savedMessage.content.substring(0, 100); // Simple preview logic
             await this.chatRepository.update(savedMessage.chatId, { preview });
         }

         // Emit events
         this.eventEmitter.emit('chatMessageAdded', { chatId: savedMessage.chatId, message: savedMessage });
         // Potentially emit an event indicating the chat list/metadata needs refresh if timestamp/preview updated
          this.eventEmitter.emit('chatMetadataUpdated', { chatId: savedMessage.chatId, timestamp: Date.now(), preview: (await this.chatRepository.findById(savedMessage.chatId))?.preview }); // Fetch updated preview or pass it

         return savedMessage;
     }

     dispose(): void {
         // No specific resources to dispose for this service beyond its dependencies
         console.log('[ChatPersistenceService] Disposed.');
     }
}